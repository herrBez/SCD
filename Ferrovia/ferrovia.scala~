import akka.actor._
import akka.actor.Actor._
import scala.collection.mutable.Queue
import scala.concurrent._
import scala.concurrent.duration._
import scala.util._
import java.util.concurrent.TimeUnit
import ExecutionContext.Implicits.global

case class Travel(who: ActorRef, to : ActorRef)
case object Load
case class Unload(capacity : Integer)
case class Send2Destination(who : ActorRef)
case object Ready2Work
case object NextStop

/**
  * Train Actor
  */
class Train(station : Array[ActorRef]) extends Actor {
  
  val max_capacity : Integer = 10;
  var actualCapacity : Integer = max_capacity;
  var nextStop : Integer = 0; // index of the next stop
  val actorName = "[" + self.path.name + "]: "


  self ! NextStop

  def receive = {
    case NextStop =>
      println(actorName + " Next stop is " + station(nextStop).path.name)
      station(nextStop) ! Unload(actualCapacity)
      station(nextStop) ! Load
      nextStop = (nextStop + 1)%station.length
      val duration = Duration.create(1000, TimeUnit.MILLISECONDS);
      //"Sleep" a little bit \equiv ignore all message till the duration is over
      context.system.scheduler.scheduleOnce(duration, self, NextStop)

    case _ => println("Train: Unrecognized Pattern");
  }
}

/**
  * Station Actor
  */
class Station extends Actor {
  // Queue[(who, destination)]
  var qStart = Queue[(ActorRef, ActorRef)]()
  var qEnd = Queue[ActorRef]()
  var knownCapacity = 0;

  val actorName = "[" + self.path.name + "]: "

  def receive = {

    case Unload(capacity : Integer) =>
      knownCapacity = capacity
      println(actorName + "Capacity = " + knownCapacity)
      

    case Load =>
      var sent:Integer = 0
      while(sent < knownCapacity && !qStart.isEmpty){
        val p = qStart.dequeue
        p._2 ! Send2Destination(p._1)
        sent = sent+1
      }
      knownCapacity = 0


    case Send2Destination(who : ActorRef) =>
      println(actorName + " enqueue " + who.path.name)
      qEnd.enqueue(who)

    case Travel(who: ActorRef, to : ActorRef) =>
      println("[" + who.path.name + "]: will travel from " + self.path.name + " to " + to.path.name)
      qStart.enqueue((who, to));


    case _ => println("Station: Unrecognized Pattern");
  }
}

/**
  * Passenger Actor 
  */
class Passenger(src : ActorRef, dest : ActorRef) extends Actor{
  var from : ActorRef  = src
  var to : ActorRef  = dest
  val workOrRestTime : Integer = 10
 
  val actorName = "[" + self.path.name + "]: "

  from ! Travel(self, to)

  def switch = {
    val tmp : ActorRef = from
    from = to
    to = tmp
  }

  def receive = {
    case Ready2Work =>
      switch
      val duration = Duration.create(workOrRestTime * 1000, TimeUnit.MILLISECONDS);
      //"Sleep" a little bit \equiv ignore all message till the duration is over
      context.system.scheduler.scheduleOnce(duration, self, NextStop)
      println(actorName + " I will go from " + from + " to " + to)
      //Do some job here a.k.a. sleep
      from ! Travel(self, to)

    case _ => println("Passenger: Unrecognized Pattern");
  }
}

object Main extends App{
  val system = ActorSystem();
  
  val s1 = system.actorOf(Props[Station], name = "S1")
  val s2 = system.actorOf(Props[Station], name = "S2")
  val s3 = system.actorOf(Props[Station], name = "S3")
  val stationList : Array[ActorRef] = Array(s1, s2, s3) 
  system.actorOf(Props(new Train(stationList)), name = "Train")
  system.actorOf(Props(new Passenger(s1, s2)), name = "P0")
}
